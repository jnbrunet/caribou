#pragma once

#include <Caribou/Topology/Grid/Internal/BaseGrid.h>

namespace caribou::topology::internal {

/**
 * Simple representation of a multidimensional (2D or 3D) Grid in space.
 *
 * ** Do not use this class directly. Use instead caribou::topology::Grid. **
 *
 * The functions declared in this class can be used with any type of grids (static grid, container grid, etc.).
 *
 * Do to so, it uses the Curiously recurring template pattern (CRTP) :
 *    https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
 *
 * A Grid is a set of multiple cell entities (same-length lines in 1D, rectangles
 * in 2D and rectangular hexahedrons in 3D) aligned in the x, y and z axis.
 *
 * @tparam Dim Dimension of the grid (1D, 2D or 3D).
 * @tparam GridType_ Type of the derived grid class that will implement the final functions.
 */
template <size_t Dim, class GridType_>
struct BaseMultidimensionalGrid : public BaseGrid<Dim, GridType_>
{
    static constexpr size_t Dimension = Dim;

    static_assert(Dimension == 2 or Dimension == 3, "Only grid of dimension 2 or 3 is allowed.");

    using GridType = GridType_;
    using Base = BaseGrid<Dim, GridType_>;

    using UInt = typename Base::UInt;
    using NodeIndex = typename Base::NodeIndex;
    using EdgeIndex = typename Base::UInt;
    using CellIndex = typename Base::CellIndex;
    using Dimensions = typename Base::Dimensions;
    using Subdivisions = typename Base::Subdivisions;
    using LocalCoordinates = typename Base::LocalCoordinates;
    using WorldCoordinates = typename Base::WorldCoordinates;
    using GridCoordinates = typename Base::GridCoordinates;
    using CellSet = typename Base::CellSet;

    using Base::Base;

    /** Get the node index at a given grid location. */
    inline auto
    node_index_at(const GridCoordinates & coordinates) const noexcept -> NodeIndex
    {
        const auto & n = Self().N();

        const auto & i = coordinates[0];
        const auto & j = coordinates[1];
        const auto &nx = n[0]+1;

        if CONSTEXPR_IF (Dimension == 2) {
            return j * nx + i;
        } else { // Dimension == 3
            const auto & k = coordinates[2];
            const auto & ny = n[1]+1;

            return k*ny*nx + j*nx + i;
        }
    }

    /** Get the grid location of the node at the given node index */
    inline auto
    node_coordinates_at(const NodeIndex & index) const noexcept -> GridCoordinates
    {
        const auto & n = Self().N();
        const auto & nx = n[0];
        const auto & ny = n[1];

        if CONSTEXPR_IF (Dimension == 2) {
            const auto j = index / (nx+1);
            const auto i = index - (j*(nx+1));

            return GridCoordinates (i,j);
        } else {
            const auto k = index / ((nx+1)*(ny+1));
            const auto j = (index - (k*(nx+1)*(ny+1))) / (nx+1);
            const auto i = index - ((k*(nx+1)*(ny+1)) + (j*(nx+1)));

            return GridCoordinates (i, j, k);
        }
    }

    /** Get the node location in world coordinates at node index */
    inline auto
    node(const NodeIndex & index) const noexcept -> WorldCoordinates
    {
        const auto & n = Self().N();
        const auto & anchor_position = Self().anchor_position();
        const auto H = Self().H();

        const auto & nx = n[0]+1;
        const auto & ny = n[1]+1;

        if CONSTEXPR_IF (Dimension == 2) {
            const auto j = index / nx;
            const auto i = index - (j*nx);
            const GridCoordinates coordinates (i, j);

            return anchor_position + (H.array() * coordinates.array().template cast<FLOATING_POINT_TYPE>()).matrix();
        } else {

            const auto k = index / (nx*ny);
            const auto j = (index - (k*nx*ny)) / nx;
            const auto i = index - ((k*nx*ny) + (j*nx));
            const GridCoordinates coordinates (i, j, k);

            return anchor_position + (H.array() * coordinates.array().template cast<FLOATING_POINT_TYPE>()).matrix();
        }
    }

    /** Get the cell index at a given grid location. */
    inline auto
    cell_index_at(const GridCoordinates & coordinates) const noexcept -> CellIndex
    {
        const auto & n = Self().N();

        const auto & i = coordinates[0];
        const auto & j = coordinates[1];

        const auto &nx = n[0];

        // Index is generated by looking at the cells as a flatten array
        if CONSTEXPR_IF (Dimension == 2) {
            return j * nx + i;
        } else {
            const auto & k = coordinates[2];
            const auto & ny = n[1];

            return k*ny*nx + j*nx + i;
        }
    }

    /** Get the grid location of the cell at the given cell index */
    inline auto
    cell_coordinates_at(const CellIndex & index) const noexcept -> GridCoordinates
    {
        const auto & n = Self().N();
        const auto & nx = n[0];
        const auto & ny = n[1];

        if CONSTEXPR_IF (Dimension == 2) {
            const auto j = index / nx;
            const auto i = index - (j*nx);

            return GridCoordinates (i,j);
        } else {
            const auto k = index / (nx*ny);
            const auto j = (index - (k*nx*ny)) / nx;
            const auto i = index - ((k*nx*ny) + (j*nx));

            return GridCoordinates (i, j, k);
        }
    }

private:
    inline constexpr
    const GridType &
    Self() const
    {
        return static_cast<const GridType &> (*this);
    }

};

} // namespace caribou::topology::internal
